import unittest


def find_next_mergeable(sorted_list, start_index):
    """Finds the next consecutive elements to be merged."""
    
    if (not sorted_list):
        return []
    elif (start_index == len(sorted_list) - 1):
        return [sorted_list[-1]]

    reference = sorted_list[start_index]
    next_mergeable = [sorted_list[start_index]]
    i = start_index + 1
    length = len(sorted_list)
    
    while i < length:
        if (sorted_list[i][0] <= reference[1]):
            next_mergeable.append(sorted_list[i])
        elif (i > 0) and (sorted_list[i][0] == sorted_list[i-1][1]):
            next_mergeable.append(sorted_list[i])
        else:
            break  # consecutive!
            
        i += 1
    
    return next_mergeable



def merge_range(meetings):
    """Merges a list of tuples into a single tuple."""
    
    if not meetings:
        return meetings
    elif len(meetings) == 1:
        return meetings[0]
        
    return (meetings[0][0],
            max([meeting[1] for meeting in meetings]))



def merge_ranges(meetings):
    
    # Sort meetings:
    sorted_meetings = sorted(meetings)

    # Merge meeting ranges:
    merged_meetings = []
    current_index = 0
    length = len(sorted_meetings)
    
    while current_index < length:
        next_mergeable = find_next_mergeable(sorted_meetings,
                                             current_index)

        if (next_mergeable):
            next_merged = merge_range(next_mergeable)
            merged_meetings.append(next_merged)
        
        current_index += len(next_mergeable)

    return merged_meetings


# learned: result of tuple sorting + sort/sorted + when to break


# Tests

class Test(unittest.TestCase):

    def test_meetings_overlap(self):
        actual = merge_ranges([(1, 3), (2, 4)])
        expected = [(1, 4)]
        self.assertEqual(actual, expected)

    def test_meetings_touch(self):
        actual = merge_ranges([(5, 6), (6, 8)])
        expected = [(5, 8)]
        self.assertEqual(actual, expected)

    def test_meeting_contains_other_meeting(self):
        actual = merge_ranges([(1, 8), (2, 5)])
        expected = [(1, 8)]
        self.assertEqual(actual, expected)

    def test_meetings_stay_separate(self):
        actual = merge_ranges([(1, 3), (4, 8)])
        expected = [(1, 3), (4, 8)]
        self.assertEqual(actual, expected)

    def test_multiple_merged_meetings(self):
        actual = merge_ranges([(1, 4), (2, 5), (5, 8)])
        expected = [(1, 8)]
        self.assertEqual(actual, expected)

    def test_meetings_not_sorted(self):
        actual = merge_ranges([(5, 8), (1, 4), (6, 8)])
        expected = [(1, 4), (5, 8)]
        self.assertEqual(actual, expected)

    def test_one_long_meeting_contains_smaller_meetings(self):
        actual = merge_ranges([(1, 10), (2, 5), (6, 8), (9, 10), (10, 12)])
        expected = [(1, 12)]
        self.assertEqual(actual, expected)

    def test_sample_input(self):
        actual = merge_ranges([(0, 1), (3, 5), (4, 8), (10, 12), (9, 10)])
        expected = [(0, 1), (3, 8), (9, 12)]
        self.assertEqual(actual, expected)


unittest.main(verbosity=2)